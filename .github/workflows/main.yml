name: Auto-Setup Telegram Bot VPS

on:
  workflow_dispatch:

jobs:
  setup-vps:
    runs-on: ubuntu-latest
    timeout-minutes: 180

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Update & Upgrade System
        run: |
          sudo apt-get update -y
          sudo apt-get upgrade -y

      - name: Install Python, Git, Curl, Wget
        run: |
          sudo apt-get install -y python3 python3-pip python3-venv git curl wget

      - name: Create Python Virtual Environment
        run: |
          python3 -m venv /opt/telegram_bot
          source /opt/telegram_bot/bin/activate
          /opt/telegram_bot/bin/pip install --upgrade pip

      - name: Install Required Python Libraries
        run: |
          source /opt/telegram_bot/bin/activate
          pip install python-telegram-bot requests beautifulsoup4 flask django numpy pandas psutil aiohttp telethon pyrogram selenium openai google-api-python-client

      - name: Create Bot Folder & Copy Bot Script
        run: |
          sudo mkdir -p /opt/telegram_bot_app
          cat > /opt/telegram_bot_app/bot.py << 'BOTPY'
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os, json, time, threading, subprocess, sys, logging
from concurrent.futures import ThreadPoolExecutor
from urllib import request, parse

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/opt/telegram_bot_app/bot.log'),
        logging.StreamHandler()
    ]
)

TOKEN = "8407863189:AAFymLb1zhM4Gq2q7YSIKhV5M37K8eTunRk"
BASE = "https://api.telegram.org/bot" + TOKEN
GETUPDATES = BASE + "/getUpdates"
SENDMSG = BASE + "/sendMessage"
OFFSET_FILE = "/opt/telegram_bot_app/offset.txt"

UPLOAD_FOLDER = "/opt/telegram_bot_app/uploaded_files"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

active_processes = {}
file_status = {}
process_outputs = {}
user_states = {}

LONG_POLL = 5
MAX_WORKERS = 30
MSG_BATCH = [
    "ðŸš€ **Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª Ø³ÙŠÙÙˆ Ø§Ù„Ù…ØªØ·ÙˆØ±!**\n\nâš¡ Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¹Ù„Ù‰ VPS Ù…Ø­ØªØ±Ù\nðŸ“Š Ø§Ù„Ø£Ø¯Ø§Ø¡: Ø£Ù‚ØµÙ‰ Ø³Ø±Ø¹Ø©\nðŸ›¡ï¸ Ø§Ù„Ø§Ø³ØªÙ‚Ø±Ø§Ø±: 100%\n\nØ§Ø®ØªØ± Ø£Ø­Ø¯ Ø§Ù„Ø®ÙŠØ§Ø±Ø§Øª:",
]

def get_main_keyboard():
    return {
        "keyboard": [
            [{"text": "ðŸ“¤ Ø±ÙØ¹ Ù…Ù„Ù Ø¨Ø§ÙŠØ«ÙˆÙ†"}, {"text": "ðŸ“ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„ÙØ§Øª"}],
            [{"text": "ðŸ“¦ ØªØ«Ø¨ÙŠØª Ù…ÙƒØªØ¨Ø©"}, {"text": "ðŸ”§ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù†Ø¸Ø§Ù…"}],
            [{"text": "ðŸ”„ ØªØ­Ø¯ÙŠØ«"}, {"text": "ðŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª"}]
        ],
        "resize_keyboard": True
    }

def read_offset():
    try:
        if os.path.exists(OFFSET_FILE):
            with open(OFFSET_FILE, 'r') as f:
                return int(f.read().strip())
    except:
        pass
    return None

def write_offset(v):
    try:
        with open(OFFSET_FILE, 'w') as f:
            f.write(str(v))
    except:
        pass

def send(chat_id, text, reply_markup=None):
    try:
        data = {"chat_id": chat_id, "text": text, "parse_mode": "Markdown"}
        if reply_markup:
            data["reply_markup"] = json.dumps(reply_markup)
        body = parse.urlencode(data).encode()
        req = request.Request(SENDMSG, data=body)
        request.urlopen(req, timeout=10)
    except Exception as e:
        logging.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥Ø±Ø³Ø§Ù„: {e}")

def download_telegram_file(file_id, file_name):
    try:
        file_info_url = f"{BASE}/getFile?file_id={file_id}"
        with request.urlopen(file_info_url) as response:
            file_info = json.loads(response.read().decode())
        if file_info["ok"]:
            file_path = file_info["result"]["file_path"]
            download_url = f"https://api.telegram.org/file/bot{TOKEN}/{file_path}"
            with request.urlopen(download_url) as file_response:
                file_content = file_response.read()
            local_path = os.path.join(UPLOAD_FOLDER, file_name)
            with open(local_path, 'wb') as f:
                f.write(file_content)
            os.chmod(local_path, 0o755)
            return True
        return False
    except Exception as e:
        logging.error(f"Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„Ù: {e}")
        return False

def run_python_file(filename, chat_id):
    try:
        file_path = os.path.join(UPLOAD_FOLDER, filename)
        if not os.path.exists(file_path):
            return f"âŒ Ø§Ù„Ù…Ù„Ù `{filename}` ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯"
        if filename in active_processes:
            try:
                active_processes[filename].terminate()
                time.sleep(2)
            except:
                pass
        process = subprocess.Popen(
            [sys.executable, "-u", file_path],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            stdin=subprocess.PIPE,
            text=True,
            bufsize=1,
            universal_newlines=True,
            cwd=UPLOAD_FOLDER
        )
        active_processes[filename] = process
        file_status[filename] = {
            "status": "running",
            "start_time": time.time(),
            "restart_count": file_status.get(filename, {}).get("restart_count", 0) + 1,
            "chat_id": chat_id,
            "pid": process.pid
        }
        threading.Thread(target=monitor_with_auto_restart, args=(process, filename, chat_id), daemon=True).start()
        threading.Thread(target=read_output, args=(process, filename, chat_id), daemon=True).start()
        return f"âœ… ØªÙ… ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù„Ù `{filename}` Ø¨Ù†Ø¬Ø§Ø­!\nðŸ†” PID: `{process.pid}`\nâš¡ Ø§Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ©: Ù…ÙØ¹Ù„Ø©"
    except Exception as e:
        return f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªØ´ØºÙŠÙ„: `{str(e)}`"

def monitor_with_auto_restart(process, filename, chat_id):
    max_restarts = 999
    restart_delay = 3
    while file_status.get(filename, {}).get("status") == "running":
        exit_code = process.wait()
        if file_status.get(filename, {}).get("status") == "running":
            current_restarts = file_status[filename].get("restart_count", 0)
            if current_restarts < max_restarts:
                logging.info(f"Ø¥Ø¹Ø§Ø¯Ø© ØªØ´ØºÙŠÙ„ ØªÙ„Ù‚Ø§Ø¦ÙŠ Ù„Ù€ {filename} (Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© {current_restarts + 1})")
                time.sleep(restart_delay)
                try:
                    new_process = subprocess.Popen(
                        [sys.executable, "-u", os.path.join(UPLOAD_FOLDER, filename)],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        stdin=subprocess.PIPE,
                        text=True,
                        bufsize=1,
                        universal_newlines=True,
                        cwd=UPLOAD_FOLDER
                    )
                    active_processes[filename] = new_process
                    file_status[filename]["restart_count"] = current_restarts + 1
                    file_status[filename]["start_time"] = time.time()
                    file_status[filename]["pid"] = new_process.pid
                    process = new_process
                    threading.Thread(target=read_output, args=(new_process, filename, chat_id), daemon=True).start()
                except Exception as e:
                    logging.error(f"ÙØ´Ù„ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ´ØºÙŠÙ„: {e}")
                    break
            else:
                send(chat_id, f"â¹ ØªÙˆÙ‚Ù `{filename}` Ø¨Ø¹Ø¯ {max_restarts} Ù…Ø­Ø§ÙˆÙ„Ø©")
                file_status[filename]["status"] = "stopped"
                break
        else:
            break

def read_output(process, filename, chat_id):
    try:
        while process.poll() is None:
            output = process.stdout.readline()
            if output:
                process_outputs[filename] = output.strip()
                if any(keyword in output.lower() for keyword in ['error', 'exception', 'traceback', 'failed']):
                    send(chat_id, f"ðŸ“„ `{filename}`:\n```\n{output[-500:]}\n```")
            error_output = process.stderr.readline()
            if error_output:
                send(chat_id, f"âŒ `{filename}` Ø®Ø·Ø£:\n```\n{error_output[-500:]}\n```")
            time.sleep(0.1)
    except:
        pass

def stop_file(filename):
    try:
        if filename in active_processes:
            process = active_processes[filename]
            file_status[filename]["status"] = "stopped"
            process.terminate()
            try:
                process.wait(timeout=5)
            except:
                process.kill()
            del active_processes[filename]
            return f"âœ… ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ù„Ù `{filename}`"
        return "âŒ Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ø´ØºØ§Ù„"
    except Exception as e:
        return f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù: `{str(e)}`"

def list_files():
    files = [f for f in os.listdir(UPLOAD_FOLDER) if f.endswith('.py')]
    if not files:
        return "ðŸ“ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„ÙØ§Øª Ù…Ø±ÙÙˆØ¹Ø© Ø¨Ø¹Ø¯"
    result = "ðŸ“ **Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¹Ø©:**\n\n"
    for file in files:
        status = "ðŸŸ¢ Ø´ØºØ§Ù„" if file in active_processes and active_processes[file].poll() is None else "ðŸ”´ Ù…ØªÙˆÙ‚Ù"
        restart_count = file_status.get(file, {}).get("restart_count", 0)
        result += f"â€¢ `{file}` - {status} (Ø¥Ø¹Ø§Ø¯Ø©: {restart_count})\n"
    return result

def install_library(lib_name):
    try:
        pip_path = "/opt/telegram_bot/bin/pip"
        result = subprocess.run(
            [pip_path, "install", lib_name],
            capture_output=True,
            text=True,
            timeout=120
        )
        if result.returncode == 0:
            return f"âœ… ØªÙ… ØªØ«Ø¨ÙŠØª `{lib_name}` Ø¨Ù†Ø¬Ø§Ø­!\n```\n{result.stdout[-1000:]}\n```"
        else:
            return f"âŒ ÙØ´Ù„ ØªØ«Ø¨ÙŠØª `{lib_name}`\n```\n{result.stderr[-1000:]}\n```"
    except subprocess.TimeoutExpired:
        return f"â° Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª ØªØ«Ø¨ÙŠØª `{lib_name}`"
    except Exception as e:
        return f"âŒ Ø®Ø·Ø£: `{str(e)}`"

def get_system_stats():
    try:
        memory = subprocess.run(["free", "-h"], capture_output=True, text=True).stdout
        disk = subprocess.run(["df", "-h"], capture_output=True, text=True).stdout
        active_count = sum(1 for p in active_processes.values() if p.poll() is None)
        stats = f"ðŸ“Š **Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù…:**\n\n"
        stats += f"ðŸ–¥ **Ø§Ù„Ø¹Ù…Ù„ÙŠØ§Øª Ø§Ù„Ù†Ø´Ø·Ø©:** {active_count}\n"
        stats += f"ðŸ“ **Ø§Ù„Ù…Ù„ÙØ§Øª Ø§Ù„Ù…Ø±ÙÙˆØ¹Ø©:** {len([f for f in os.listdir(UPLOAD_FOLDER) if f.endswith('.py')])}\n"
        stats += f"â° **ÙˆÙ‚Øª Ø§Ù„ØªØ´ØºÙŠÙ„:** {int(time.time() - start_time)} Ø«Ø§Ù†ÙŠØ©\n"
        return stats
    except Exception as e:
        return f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª: {str(e)}"

def handle_message(chat_id, text, pool):
    if text == "ðŸ“¤ Ø±ÙØ¹ Ù…Ù„Ù Ø¨Ø§ÙŠØ«ÙˆÙ†":
        user_states[chat_id] = "waiting_for_file"
        send(chat_id, "ðŸ“¤ **Ø±ÙØ¹ Ù…Ù„Ù Ø¨Ø§ÙŠØ«ÙˆÙ†**\n\nØ£Ø±Ø³Ù„ Ù…Ù„Ù Ø¨Ø§ÙŠØ«ÙˆÙ† (.py) Ø§Ù„Ø¢Ù†:\nâ€¢ Ø§Ù„ØªØ´ØºÙŠÙ„ Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ Ø§Ù„ÙÙˆØ±ÙŠ\nâ€¢ Ø§Ù„Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠØ© Ø¹Ù†Ø¯ Ø§Ù„ØªÙˆÙ‚Ù\nâ€¢ Ø¯Ø¹Ù… ÙƒØ§Ù…Ù„ Ù„Ù„Ù…ÙƒØªØ¨Ø§Øª")
    elif text == "ðŸ“ Ø¹Ø±Ø¶ Ø§Ù„Ù…Ù„ÙØ§Øª":
        files_info = list_files()
        send(chat_id, files_info)
    elif text == "ðŸ“¦ ØªØ«Ø¨ÙŠØª Ù…ÙƒØªØ¨Ø©":
        user_states[chat_id] = "waiting_for_library"
        send(chat_id, "ðŸ“¦ **ØªØ«Ø¨ÙŠØª Ù…ÙƒØªØ¨Ø©**\n\nØ£Ø±Ø³Ù„ Ø§Ø³Ù… Ø§Ù„Ù…ÙƒØªØ¨Ø©:")
    elif text == "ðŸ”§ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù†Ø¸Ø§Ù…":
        stats = get_system_stats()
        send(chat_id, stats)
    elif text == "ðŸ“Š Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª":
        stats = get_system_stats()
        send(chat_id, stats)
    elif text.startswith("/install "):
        lib_name = text.replace("/install ", "").strip()
        if lib_name:
            send(chat_id, f"â³ Ø¬Ø§Ø±ÙŠ ØªØ«Ø¨ÙŠØª `{lib_name}`...")
            result = install_library(lib_name)
            send(chat_id, result)
    elif user_states.get(chat_id) == "waiting_for_library":
        lib_name = text.strip()
        user_states[chat_id] = None
        send(chat_id, f"â³ Ø¬Ø§Ø±ÙŠ ØªØ«Ø¨ÙŠØª `{lib_name}`...")
        result = install_library(lib_name)
        send(chat_id, result)
    else:
        send(chat_id, MSG_BATCH[0], get_main_keyboard())

def handle_update(upd, pool):
    try:
        if "message" in upd:
            msg = upd["message"]
            chat_id = msg.get("chat", {}).get("id")
            text = msg.get("text", "")
            if text:
                pool.submit(handle_message, chat_id, text, pool)
    except Exception as e:
        logging.error(f"Ø®Ø·Ø£ ÙÙŠ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØªØ­Ø¯ÙŠØ«: {e}")

def main_loop():
    global start_time
    start_time = time.time()
    pool = ThreadPoolExecutor(MAX_WORKERS)
    offset = read_offset()
    logging.info("ðŸš€ Ø¨Ø¯Ø¡ ØªØ´ØºÙŠÙ„ Ø¨ÙˆØª VPS Ø§Ù„Ù…ØªØ·ÙˆØ±...")
    while True:
        try:
            params = {"timeout": LONG_POLL, "limit": 100}
            if offset is not None:
                params["offset"] = offset
            full_url = GETUPDATES + "?" + parse.urlencode(params)
            with request.urlopen(full_url, timeout=LONG_POLL+10) as resp:
                data = json.loads(resp.read().decode())
            updates = data.get("result", [])
            for upd in updates:
                uid = upd.get("update_id")
                if uid is not None:
                    offset = uid + 1
                    write_offset(offset)
                threading.Thread(target=handle_update, args=(upd, pool), daemon=True).start()
            if not updates:
                time.sleep(0.05)
        except Exception as e:
            logging.error(f"Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©: {e}")
            time.sleep(1)

if __name__ == "__main__":
    main_loop()
BOTPY

      - name: Make bot executable
        run: |
          chmod +x /opt/telegram_bot_app/bot.py

      - name: Create systemd service
        run: |
          sudo bash -c 'cat > /etc/systemd/system/telegram-bot.service << EOF
[Unit]
Description=Telegram Bot for Python Files Management
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/opt/telegram_bot_app
Environment=PATH=/opt/telegram_bot/bin
ExecStart=/opt/telegram_bot/bin/python /opt/telegram_bot_app/bot.py
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF'

      - name: Reload and start service
        run: |
          sudo systemctl daemon-reload
          sudo systemctl enable telegram-bot.service
          sudo systemctl start telegram-bot.service
          sudo systemctl status telegram-bot.service --no-pager
