name: RDP with Auto Telegram Bot
on:
  workflow_dispatch:
jobs:
  secure-rdp:
    runs-on: windows-latest
    timeout-minutes: 10080
    steps:
      - name: Configure RDP Settings
        run: |
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 0 -Force
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "SecurityLayer" -Value 0 -Force
          netsh advfirewall firewall set rule group="remote desktop" new enable=Yes
          netsh advfirewall firewall add rule name="RDP-Bot" dir=in action=allow protocol=TCP localport=3389
          Restart-Service -Name TermService -Force
          Write-Host "‚úÖ RDP configured successfully"

      - name: Create User Account
        run: |
          $password = "P@ssw0rd123"
          $securePass = ConvertTo-SecureString $password -AsPlainText -Force
          Remove-LocalUser -Name "SIFODZ" -ErrorAction SilentlyContinue
          Start-Sleep -Seconds 3
          New-LocalUser -Name "SIFODZ" -Password $securePass -AccountNeverExpires
          Add-LocalGroupMember -Group "Administrators" -Member "SIFODZ"
          Add-LocalGroupMember -Group "Remote Desktop Users" -Member "SIFODZ"
          Enable-LocalUser -Name "SIFODZ"
          Write-Host "‚úÖ User account created"

      - name: Install Python and Packages
        run: |
          # Download and install Python silently
          $pythonUrl = "https://www.python.org/ftp/python/3.11.9/python-3.11.9-amd64.exe"
          $installerPath = "$env:TEMP\python-installer.exe"
          
          Invoke-WebRequest -Uri $pythonUrl -OutFile $installerPath
          Start-Process -FilePath $installerPath -ArgumentList "/quiet", "InstallAllUsers=1", "PrependPath=1", "Include_test=0", "Include_pip=1" -Wait
          Remove-Item $installerPath -Force
          
          # Wait for installation and refresh environment
          Start-Sleep -Seconds 15
          refreshenv
          
          # Upgrade pip and install all required packages
          python -m pip install --upgrade pip
          pip install requests telethon python-telegram-bot pyrogram tweepy beautifulsoup4 selenium pillow numpy pandas opencv-python flask django fastapi sqlalchemy psutil pyautogui
          
          Write-Host "‚úÖ Python and all packages installed successfully"

      - name: Create Bot Startup Script
        run: |
          # Create bot directory
          $botDir = "C:\TelegramBot"
          New-Item -ItemType Directory -Path $botDir -Force
          
          # Create the bot script
          $botScript = @'
import os, json, time, threading, subprocess, sys
from concurrent.futures import ThreadPoolExecutor
from urllib import request, parse

TOKEN = "8407863189:AAFymLb1zhM4Gq2q7YSIKhV5M37K8eTunRk"
BASE = "https://api.telegram.org/bot" + TOKEN
GETUPDATES = BASE + "/getUpdates"
SENDMSG = BASE + "/sendMessage"
OFFSET_FILE = os.path.expanduser("~/.sifo_bot_offset")

UPLOAD_FOLDER = "telegram_bot_files"
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

active_processes = {}
file_status = {}
process_outputs = {}

LONG_POLL = 10
MAX_WORKERS = 25

def get_main_keyboard():
    return {
        "keyboard": [
            [{"text": "üì§ ÿ±ŸÅÿπ ŸÖŸÑŸÅ ÿ®ÿßŸäÿ´ŸàŸÜ"}],
            [{"text": "üìÅ ÿπÿ±ÿ∂ ÿßŸÑŸÖŸÑŸÅÿßÿ™"}],
            [{"text": "üì¶ ÿ™ÿ´ÿ®Ÿäÿ™ ŸÖŸÉÿ™ÿ®ÿ©"}],
            [{"text": "üîÑ ÿ™ÿ≠ÿØŸäÿ´"}]
        ],
        "resize_keyboard": True
    }

def read_offset():
    if os.path.exists(OFFSET_FILE):
        try:
            return int(open(OFFSET_FILE).read().strip())
        except:
            return None
    return None

def write_offset(v):
    try:
        open(OFFSET_FILE, "w").write(str(v))
    except:
        pass

def send(chat_id, text, reply_markup=None):
    try:
        data = {"chat_id": chat_id, "text": text, "parse_mode": "Markdown"}
        if reply_markup:
            data["reply_markup"] = json.dumps(reply_markup)
        body = parse.urlencode(data).encode()
        req = request.Request(SENDMSG, data=body)
        request.urlopen(req, timeout=10)
    except:
        pass

def download_file(file_id, file_name):
    try:
        file_info_url = f"{BASE}/getFile?file_id={file_id}"
        with request.urlopen(file_info_url) as response:
            file_info = json.loads(response.read().decode())
        
        if file_info["ok"]:
            file_path = file_info["result"]["file_path"]
            download_url = f"https://api.telegram.org/file/bot{TOKEN}/{file_path}"
            
            with request.urlopen(download_url) as file_response:
                file_content = file_response.read()
            
            local_path = os.path.join(UPLOAD_FOLDER, file_name)
            with open(local_path, 'wb') as f:
                f.write(file_content)
            
            return True
        return False
    except Exception as e:
        print(f"Download error: {e}")
        return False

def run_python_file(filename, chat_id):
    try:
        file_path = os.path.join(UPLOAD_FOLDER, filename)
        if not os.path.exists(file_path):
            return f"‚ùå File `{filename}` not found"
        
        if filename in active_processes:
            try:
                active_processes[filename].terminate()
                time.sleep(2)
            except:
                pass
        
        process = subprocess.Popen(
            [sys.executable, "-u", file_path],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            stdin=subprocess.PIPE,
            text=True,
            bufsize=1,
            universal_newlines=True
        )
        
        active_processes[filename] = process
        file_status[filename] = {
            "status": "running",
            "start_time": time.time(),
            "restart_count": file_status.get(filename, {}).get("restart_count", 0) + 1,
            "chat_id": chat_id
        }
        
        threading.Thread(target=monitor_process_with_restart, args=(process, filename, chat_id), daemon=True).start()
        threading.Thread(target=read_process_output, args=(process, filename, chat_id), daemon=True).start()
        
        return f"‚úÖ Started `{filename}` successfully!\nüÜî PID: `{process.pid}`\nüîÑ Auto-restart enabled"
        
    except Exception as e:
        return f"‚ùå Run error: `{str(e)}`"

def monitor_process_with_restart(process, filename, chat_id):
    max_restarts = 10
    restart_delay = 5
    
    while file_status.get(filename, {}).get("status") == "running":
        exit_code = process.wait()
        
        if file_status.get(filename, {}).get("status") == "running":
            current_restarts = file_status[filename].get("restart_count", 0)
            
            if current_restarts < max_restarts:
                send(chat_id, f"üîÑ Restarting `{filename}`... (Attempt {current_restarts + 1})")
                time.sleep(restart_delay)
                
                try:
                    new_process = subprocess.Popen(
                        [sys.executable, "-u", os.path.join(UPLOAD_FOLDER, filename)],
                        stdout=subprocess.PIPE,
                        stderr=subprocess.PIPE,
                        stdin=subprocess.PIPE,
                        text=True,
                        bufsize=1,
                        universal_newlines=True
                    )
                    
                    active_processes[filename] = new_process
                    file_status[filename]["restart_count"] = current_restarts + 1
                    file_status[filename]["start_time"] = time.time()
                    
                    process = new_process
                    threading.Thread(target=read_process_output, args=(new_process, filename, chat_id), daemon=True).start()
                    
                    send(chat_id, f"‚úÖ Restarted `{filename}` successfully!")
                    
                except Exception as e:
                    send(chat_id, f"‚ùå Restart failed: `{str(e)}`")
                    break
            else:
                send(chat_id, f"‚èπ Stopped `{filename}` after {max_restarts} restart attempts")
                file_status[filename]["status"] = "stopped"
                break
        else:
            break

def read_process_output(process, filename, chat_id):
    try:
        while process.poll() is None:
            output = process.stdout.readline()
            if output:
                process_outputs[filename] = output.strip()
                if any(keyword in output.lower() for keyword in ['error', 'exception', 'traceback', 'failed']):
                    send(chat_id, f"üìÑ `{filename}`:\n```\n{output[-500:]}\n```")
            
            error_output = process.stderr.readline()
            if error_output:
                send(chat_id, f"‚ùå `{filename}` error:\n```\n{error_output[-500:]}\n```")
                
            time.sleep(0.1)
    except:
        pass

def stop_file(filename):
    try:
        if filename in active_processes:
            process = active_processes[filename]
            file_status[filename]["status"] = "stopped"
            process.terminate()
            try:
                process.wait(timeout=5)
            except:
                process.kill()
            del active_processes[filename]
            return f"‚úÖ Stopped `{filename}`"
        else:
            return "‚ùå File not running"
    except Exception as e:
        return f"‚ùå Stop error: `{str(e)}`"

def list_files():
    files = [f for f in os.listdir(UPLOAD_FOLDER) if f.endswith('.py')]
    if not files:
        return "üìÅ No files uploaded yet"
    
    result = "üìÅ **Uploaded Files:**\n\n"
    for i, file in enumerate(files, 1):
        status = "üü¢ Running" if file in active_processes and active_processes[file].poll() is None else "üî¥ Stopped"
        restart_count = file_status.get(file, {}).get("restart_count", 0)
        result += f"{i}. `{file}` - {status} (Restarts: {restart_count})\n"
    
    return result

def install_library(lib_name):
    try:
        result = subprocess.run(
            [sys.executable, "-m", "pip", "install", lib_name],
            capture_output=True,
            text=True,
            timeout=120
        )
        
        if result.returncode == 0:
            return f"‚úÖ Installed `{lib_name}` successfully!\n\nOutput:\n```\n{result.stdout[-800:]}\n```"
        else:
            return f"‚ùå Failed to install `{lib_name}`\n\nError:\n```\n{result.stderr[-800:]}\n```"
            
    except subprocess.TimeoutExpired:
        return f"‚è∞ Installation timeout for `{lib_name}`"
    except Exception as e:
        return f"‚ùå Installation error: `{str(e)}`"

def handle_message(chat_id, text, pool):
    if text == "üì§ ÿ±ŸÅÿπ ŸÖŸÑŸÅ ÿ®ÿßŸäÿ´ŸàŸÜ":
        send(chat_id, "üì§ **Upload Python File**\n\nSend a Python file (.py) now:\n‚Ä¢ Auto-save\n‚Ä¢ Auto-run with restart\n‚Ä¢ Continuous monitoring")
    
    elif text == "üìÅ ÿπÿ±ÿ∂ ÿßŸÑŸÖŸÑŸÅÿßÿ™":
        files_info = list_files()
        send(chat_id, files_info)
        
        files = [f for f in os.listdir(UPLOAD_FOLDER) if f.endswith('.py')]
        for file in files:
            status = "üü¢ Running" if file in active_processes and active_processes[file].poll() is None else "üî¥ Stopped"
            keyboard = {
                "inline_keyboard": [
                    [
                        {"text": "‚ñ∂Ô∏è Run", "callback_data": f"run_{file}"},
                        {"text": "‚èπ Stop", "callback_data": f"stop_{file}"},
                        {"text": "üîÅ Restart", "callback_data": f"restart_{file}"}
                    ],
                    [
                        {"text": "üìä Status", "callback_data": f"status_{file}"},
                        {"text": "üóë Delete", "callback_data": f"delete_{file}"}
                    ]
                ]
            }
            send(chat_id, f"üìÑ `{file}`\nüìä {status}", keyboard)
    
    elif text == "üì¶ ÿ™ÿ´ÿ®Ÿäÿ™ ŸÖŸÉÿ™ÿ®ÿ©":
        send(chat_id, "üì¶ **Install Library**\n\nSend library name to install:\nExample: `requests` or `numpy pandas`\n\nOr use command:\n`/install library_name`")
    
    elif text == "üîÑ ÿ™ÿ≠ÿØŸäÿ´":
        send(chat_id, "üîÑ **Menu Updated**", get_main_keyboard())
    
    elif text.startswith("/install "):
        lib_name = text.replace("/install ", "").strip()
        if lib_name:
            send(chat_id, f"‚è≥ Installing `{lib_name}`...")
            result = install_library(lib_name)
            send(chat_id, result)
        else:
            send(chat_id, "‚ùå Please specify library name")
    
    else:
        send(chat_id, "üöÄ **Welcome to SIFO Advanced Bot!**\n\nChoose an option:", get_main_keyboard())

def handle_update(upd, pool):
    try:
        if "message" in upd:
            msg = upd["message"]
            chat_id = msg.get("chat", {}).get("id")
            text = msg.get("text", "")
            
            if text:
                pool.submit(handle_message, chat_id, text, pool)
        
        if "message" in upd and "document" in upd["message"]:
            doc = upd["message"]["document"]
            chat_id = upd["message"]["chat"]["id"]
            file_name = doc.get("file_name", "")
            
            if file_name.endswith('.py'):
                file_id = doc["file_id"]
                send(chat_id, f"‚è≥ Uploading `{file_name}`...")
                
                if download_file(file_id, file_name):
                    send(chat_id, f"‚úÖ Uploaded `{file_name}` successfully!\n‚ö° Starting auto-run...")
                    result = run_python_file(file_name, chat_id)
                    send(chat_id, result)
                else:
                    send(chat_id, "‚ùå Upload failed")
            else:
                send(chat_id, "‚ùå Please upload Python files only (.py extension)")
        
        if "callback_query" in upd:
            callback = upd["callback_query"]
            chat_id = callback["message"]["chat"]["id"]
            data = callback["data"]
            
            if data.startswith("run_"):
                filename = data[4:]
                send(chat_id, f"‚ö° Starting `{filename}`...")
                result = run_python_file(filename, chat_id)
                send(chat_id, result)
            
            elif data.startswith("stop_"):
                filename = data[5:]
                result = stop_file(filename)
                send(chat_id, result)
            
            elif data.startswith("restart_"):
                filename = data[8:]
                send(chat_id, f"üîÅ Restarting `{filename}`...")
                stop_file(filename)
                time.sleep(2)
                result = run_python_file(filename, chat_id)
                send(chat_id, result)
            
            elif data.startswith("status_"):
                filename = data[7:]
                if filename in file_status:
                    status = file_status[filename]
                    uptime = time.time() - status["start_time"]
                    status_text = f"üìä **File Status:** `{filename}`\n"
                    status_text += f"üü¢ **Status:** {status['status']}\n"
                    status_text += f"‚è± **Uptime:** {int(uptime)} seconds\n"
                    status_text += f"üîÑ **Restarts:** {status['restart_count']}\n"
                    if filename in active_processes:
                        status_text += f"üÜî **PID:** {active_processes[filename].pid}"
                    send(chat_id, status_text)
                else:
                    send(chat_id, f"‚ùå `{filename}` not running yet")
            
            elif data.startswith("delete_"):
                filename = data[7:]
                try:
                    stop_file(filename)
                    file_path = os.path.join(UPLOAD_FOLDER, filename)
                    if os.path.exists(file_path):
                        os.remove(file_path)
                    if filename in file_status:
                        del file_status[filename]
                    send(chat_id, f"‚úÖ Deleted `{filename}`")
                except Exception as e:
                    send(chat_id, f"‚ùå Delete error: `{str(e)}`")
    
    except Exception as e:
        print(f"Update handling error: {e}")

def main_loop():
    pool = ThreadPoolExecutor(MAX_WORKERS)
    offset = read_offset()
    
    print("üöÄ Starting Advanced Python File Management Bot...")
    print("‚ö° Auto-restart feature enabled")
    print("üìÅ Files folder:", UPLOAD_FOLDER)
    
    while True:
        try:
            params = {"timeout": LONG_POLL, "limit": 100}
            if offset is not None:
                params["offset"] = offset
            full_url = GETUPDATES + "?" + parse.urlencode(params)
            with request.urlopen(full_url, timeout=LONG_POLL+10) as resp:
                data = json.loads(resp.read().decode())
            updates = data.get("result", [])
            
            for upd in updates:
                uid = upd.get("update_id")
                if uid is not None:
                    offset = uid + 1
                    write_offset(offset)
                threading.Thread(target=handle_update, args=(upd, pool), daemon=True).start()
            
            if not updates:
                time.sleep(0.05)
                
        except Exception as e:
            time.sleep(0.1)

if __name__ == "__main__":
    main_loop()
'@

          Set-Content -Path "C:\TelegramBot\bot.py" -Value $botScript -Encoding UTF8
          Write-Host "‚úÖ Bot script created successfully"

      - name: Create Auto-Start Batch File
        run: |
          $batchContent = @'
@echo off
cd /d C:\TelegramBot
echo Starting Telegram Bot...
python bot.py
pause
'@

          Set-Content -Path "C:\Users\Public\Desktop\Start Telegram Bot.bat" -Value $batchContent
          Write-Host "‚úÖ Auto-start batch file created on desktop"

      - name: Start Telegram Bot
        run: |
          # Start the bot in background
          Start-Process -FilePath "python" -ArgumentList "C:\TelegramBot\bot.py" -WindowStyle Hidden
          Write-Host "‚úÖ Telegram Bot started successfully in background"

      - name: Get Public IP
        run: |
          try {
              $publicIP = Invoke-RestMethod -Uri "https://api.ipify.org" -TimeoutSec 10
              echo "PUBLIC_IP=$publicIP" >> $env:GITHUB_ENV
              Write-Host "üåç Public IP: $publicIP"
          } catch {
              Write-Host "‚ö†Ô∏è Could not get public IP"
              echo "PUBLIC_IP=Unknown" >> $env:GITHUB_ENV
          }

      - name: Display Final Information
        run: |
          Write-Host ""
          Write-Host "üéØ ==================== RDP + TELEGRAM BOT READY ===================="
          Write-Host "üë§ Username: SIFODZ"
          Write-Host "üîë Password: P@ssw0rd123"
          Write-Host "üåê Public IP: $env:PUBLIC_IP"
          Write-Host "üîå RDP Port: 3389"
          Write-Host ""
          Write-Host "ü§ñ TELEGRAM BOT INFORMATION:"
          Write-Host "   ‚úÖ Bot is running automatically"
          Write-Host "   üîó Bot Token: 8407863189:AAFymLb1zhM4Gq2q7YSIKhV5M37K8eTunRk"
          Write-Host "   üìÅ Bot Location: C:\TelegramBot"
          Write-Host "   üñ•Ô∏è Desktop Shortcut: 'Start Telegram Bot.bat'"
          Write-Host ""
          Write-Host "üîß INSTALLED PACKAGES:"
          Write-Host "   ‚Ä¢ requests, telethon, python-telegram-bot, pyrogram"
          Write-Host "   ‚Ä¢ tweepy, beautifulsoup4, selenium, pillow"
          Write-Host "   ‚Ä¢ numpy, pandas, opencv-python, flask"
          Write-Host "   ‚Ä¢ django, fastapi, sqlalchemy, psutil, pyautogui"
          Write-Host ""
          Write-Host "üîß HOW TO CONNECT:"
          Write-Host "   1. Open Remote Desktop Connection (mstsc.exe)"
          Write-Host "   2. Computer: $env:PUBLIC_IP:3389"
          Write-Host "   3. Username: SIFODZ"
          Write-Host "   4. Password: P@ssw0rd123"
          Write-Host "   5. The bot is already running automatically"
          Write-Host ""
          Write-Host "‚è∞ Duration: 7 DAYS"
          Write-Host "================================================================"
          Write-Host ""

      - name: Keep System Active
        run: |
          $startTime = Get-Date
          Write-Host "üîÑ System is running - RDP and Telegram Bot are active..."
          
          while ($true) {
              $currentTime = Get-Date
              $elapsed = $currentTime - $startTime
              $hours = [math]::Round($elapsed.TotalHours, 1)
              
              # Check RDP service
              try {
                  $rdpService = Get-Service -Name TermService -ErrorAction Stop
                  if ($rdpService.Status -ne 'Running') {
                      Write-Host "üîÑ Restarting RDP Service..."
                      Start-Service -Name TermService
                  }
              } catch {
                  Write-Host "‚ö†Ô∏è Could not check RDP service"
              }
              
              # Check if bot is running
              $botProcess = Get-Process -Name "python" -ErrorAction SilentlyContinue | Where-Object { 
                  $_.MainModule.FileName -like "*python*" 
              }
              
              if (-not $botProcess) {
                  Write-Host "üîÑ Restarting Telegram Bot..."
                  Start-Process -FilePath "python" -ArgumentList "C:\TelegramBot\bot.py" -WindowStyle Hidden
              }
              
              Write-Host "[$(Get-Date -Format 'HH:mm:ss')] ‚úÖ System Active - $hours hours - IP: $env:PUBLIC_IP"
              Start-Sleep -Seconds 60
          }
